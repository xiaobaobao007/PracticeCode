package per.bmy.other;

import java.util.Arrays;

/**
 * 在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。
 * <p>
 * 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
 * <p>
 * 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
 * <p>
 * 我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。
 * <p>
 * 请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。
 * <p>
 *  
 * <p>
 * 示例 1：
 * <p>
 * 输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
 * 输出：0
 * 示例 2：
 * <p>
 * 输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
 * 输出：0
 * 示例 3：
 * <p>
 * 输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
 * 输出：1
 *  
 * <p>
 * 提示：
 * <p>
 * 1 < graph.length = graph[0].length <= 300
 * 0 <= graph[i][j] == graph[j][i] <= 1
 * graph[i][i] == 1
 * 1 <= initial.length < graph.length
 * 0 <= initial[i] < graph.length
 * <p>
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/minimize-malware-spread
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 *
 * @author xiaobaobao
 * @date 2020/9/20，21:19
 */
public class MinMalwareSpread {
    public static void main(String[] args) {
        int[][] a = {{1, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0}, {0, 0, 0, 1, 1, 0}, {0, 0, 0, 1, 1, 0}, {0, 0, 0, 0, 0, 1}};
        int[] b = {0, 5};
        System.out.println(new MinMalwareSpread().minMalwareSpread(a, b));
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        if (initial.length == 1) {
            return initial[0];
        }

        int N = graph.length;
        //每一个通路标记一种颜色
        int[] colorArray = new int[N];
        Arrays.fill(colorArray, -1);
        int C = 0;
        for (int node = 0; node < N; ++node) {
            if (colorArray[node] == -1) {
                dfs(graph, colorArray, node, C++);
            }
        }

        //每种颜色的数量
        int[] colorCount = new int[C];
        for (int color : colorArray)
            colorCount[color]++;

        //被感染的颜色数量
        int[] bugColorCount = new int[C];
        for (int node : initial)
            bugColorCount[colorArray[node]]++;

        int ans = Integer.MAX_VALUE;
        for (int node : initial) {
            int c = colorArray[node];
            //因为只消除一个点，此时bug点大于1个时，再消除他无用功
            if (bugColorCount[c] == 1) {
                if (ans == Integer.MAX_VALUE)
                    ans = node;
                else if (colorCount[c] > colorCount[colorArray[ans]])
                    ans = node;
                else if (colorCount[c] == colorCount[colorArray[ans]] && node < ans)
                    ans = node;
            }
        }

        // 如果颜色一样则不筛选，直接计算最小值
        if (ans == Integer.MAX_VALUE)
            for (int node : initial)
                ans = Math.min(ans, node);

        return ans;
    }

    public void dfs(int[][] graph, int[] colors, int node, int color) {
        colors[node] = color;
        for (int nei = 0; nei < graph.length; ++nei)
            if (graph[node][nei] == 1 && colors[nei] == -1)
                dfs(graph, colors, nei, color);
    }
}
