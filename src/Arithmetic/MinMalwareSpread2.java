package Arithmetic;

/**
 * 我们可以从初始列表中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接
 *
 * @author xiaobaobao
 * @date 2020/9/20，21:19
 */
public class MinMalwareSpread2 {

	public static void main(String[] args) {
		// int[][] a = {
		// 		{1, 1, 0, 0},
		// 		{1, 1, 0, 1},
		// 		{0, 0, 1, 0},
		// 		{0, 1, 0, 1}};
		// int[] b = {3, 0};//0

		int[][] a = {
				{1, 1, 0},
				{1, 1, 1},
				{0, 1, 1}};
		int[] b = {0, 1};//1

		// int[][] a = {
		// 		{1, 1, 0},
		// 		{1, 1, 0},
		// 		{0, 0, 1}};
		// int[] b = {0, 1};//0

		// int[][] a = {
		// 		{1, 0, 0, 0, 0, 0, 0, 0, 0},
		// 		{0, 1, 0, 0, 0, 0, 0, 0, 0},
		// 		{0, 0, 1, 0, 1, 0, 1, 0, 0},
		// 		{0, 0, 0, 1, 0, 0, 0, 0, 0},
		// 		{0, 0, 1, 0, 1, 0, 0, 0, 0},
		// 		{0, 0, 0, 0, 0, 1, 0, 0, 0},
		// 		{0, 0, 1, 0, 0, 0, 1, 0, 0},
		// 		{0, 0, 0, 0, 0, 0, 0, 1, 0},
		// 		{0, 0, 0, 0, 0, 0, 0, 0, 1}};
		// int[] b = {6, 0, 4};//0
		System.out.println(new MinMalwareSpread2().minMalwareSpread(a, b));
	}

	public int minMalwareSpread(int[][] graph, int[] initial) {
		int N = graph.length;
		int[] clean;
		int min = -1;
		int point = -1;
		int num;
		for (int u : initial) {
			num = 0;
			clean = new int[N];
			for (int height = graph.length - 1; height >= 0; height--) {
				if (height == u) {
					continue;
				}
				if (graph[height][u] == 1 && clean[height] == 0) {
					num += dfs(graph, clean, u, u);
				}
			}
		}

		// int[] contribution = new int[N];
		// for (int v = 0; v < N; ++v) {
		// 	if (infectedBy.get(v).size() == 1) {
		// 		contribution[infectedBy.get(v).get(0)]++;
		// 	}
		// }
		//
		// Arrays.sort(initial);
		// int ans = initial[0], ansSize = -1;
		// for (int u : initial) {
		// 	int score = contribution[u];
		// 	if (score > ansSize || score == ansSize && u < ans) {
		// 		ans = u;
		// 		ansSize = score;
		// 	}
		// }
		// return ans;
		return 0;
	}

	public int dfs(int[][] graph, int[] clean, int i, int j) {
		int num = 0;
		for (int v = 0; v < graph.length; ++v) {
			if (v == j) {
				continue;
			}
			if (graph[v][i] == 1 && clean[v] == 0) {
				clean[v] = 1;
				num += 1 + dfs(graph, clean, v, j);
			}
		}
		return num;
	}

}
